<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - geometry - cube</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

<script src="js/libs/ammo.js"></script>

<script type="module">

	import * as THREE from '../build/three.module.js';

	// 鼠标控制scene的旋转
	import {OrbitControls} from './jsm/controls/OrbitControls.js';
	import {DragControls} from './jsm/controls/DragControls.js';
	import {ConvexObjectBreaker} from './jsm/misc/ConvexObjectBreaker.js';
	import {ConvexBufferGeometry} from './jsm/geometries/ConvexGeometry.js';

	var camera, scene, renderer;
	var mesh;
	var group;
	var objects = [];
	var textureLoader;
	var clock = new THREE.Clock();

	var mouseCoords = new THREE.Vector2();
	var raycaster = new THREE.Raycaster();
	var ballMaterial = new THREE.MeshPhongMaterial({color: 0xff2020});

	// Physics variables
	var gravityConstant = 7.8;
	var collisionConfiguration;
	var dispatcher;
	var broadphase;
	var solver;
	var physicsWorld;
	var margin = 0.05;

	// Rigid bodies include all movable objects
	var rigidBodies = [];

	var pos = new THREE.Vector3();
	var quat = new THREE.Quaternion();
	var transformAux1;
	var tempBtVec3_1;

	var objectsToRemove = [];
	for (var i = 0; i < 500; i++) {

		objectsToRemove[i] = null;

	}
	var numObjectsToRemove = 0;

	var impactPoint = new THREE.Vector3();
	var impactNormal = new THREE.Vector3();

	var convexBreaker = new ConvexObjectBreaker();

	// - Main code -

	Ammo().then(function (AmmoLib) {

		Ammo = AmmoLib;

		init();
		animate();

	});

	// init();
	// animate();


	// - Functions -

	function init() {

		// camera, scene, light, renderer, controls, textureLoader
		initGraphics();

		initPhysics();

		createObjects();

		// 自定义的物理对象
		createObjects_custom();

		initInput();

	}

	function initGraphics() {

		console.log("initGraphics()");

		scene = new THREE.Scene();

		renderer = new THREE.WebGLRenderer({antialias: true});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 10, 1000);
		camera.position.z = 50;
		scene.add(camera);

		// camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );
		// camera.position.set( - 14, 8, 16 );

		// controls
		// 鼠标控制scene的旋转
		var controls = new OrbitControls(camera, renderer.domElement);
		// controls.minDistance = 20;
		// controls.maxDistance = 50;
		// controls.maxPolarAngle = Math.PI / 2;

		scene.add(new THREE.AmbientLight(0x222222));
		// light

		var light = new THREE.PointLight(0xffffff, 1);
		camera.add(light);

		// helper
		// 显示scene的坐标轴
		scene.add(new THREE.AxesHelper(150));

		textureLoader = new THREE.TextureLoader();

		////////////////////////////////////////
		// 创建对象）
		createHollowCylinder();

		// ////////////////////////////////////////
		// // 一个复合对象（group）
		// var group = new THREE.Group();

		// // 一个box几何体
		// // var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
		// var texture = new THREE.TextureLoader().load( 'textures/land_ocean_ice_cloud_2048.jpg' );
		// var material = new THREE.MeshBasicMaterial( { map: texture } );

		// var geometry = new THREE.BoxBufferGeometry( 10, 10, 10 );

		// mesh = new THREE.Mesh( geometry, material );
		// group.add( mesh );

		// // 第二个box几何体
		// // var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
		// var texture = new THREE.TextureLoader().load( 'textures/water.jpg' );
		// var material = new THREE.MeshBasicMaterial( { map: texture } );

		// // 改变大小
		// var geometry = new THREE.BoxBufferGeometry( 3, 3, 4 );
		// // geometry.scale(0.2, 0.2, 0.2);

		// mesh = new THREE.Mesh( geometry, material );
		// // 改变位置
		// mesh.translateY(-50);
		// mesh.translateZ(7.5);

		// group.add( mesh );
		// objects.push( group );

		// // 改变位置
		// group.translateX(20);
		// group.add( new THREE.AxesHelper( 100 ) );

		// // 一个group添加到scene
		// scene.add( group );

		// // Tower 1
		// var towerMass = 1000;
		// var towerHalfExtents = new THREE.Vector3( 2, 5, 2 );
		// pos.set( - 8, 5, 0 );
		// quat.set( 0, 0, 0, 1 );
		// createObject_byMesh( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xB03014 ), mesh );

		// ////////////////////////////////////////
		// // 一个复合对象（group）
		// var group = new THREE.Group();

		// // 一个box几何体
		// // var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
		// var texture = new THREE.TextureLoader().load( 'textures/01.jpg' );
		// var material = new THREE.MeshBasicMaterial( { map: texture } );

		// var geometry = new THREE.BoxBufferGeometry( 50, 50, 50 );

		// mesh = new THREE.Mesh( geometry, material );
		// objects.push( mesh );

		// group.add( mesh );

		// // 第二个box几何体
		// var texture = new THREE.TextureLoader().load( 'textures/water.jpg' );
		// // var texture = new THREE.TextureLoader().load( 'textures/01.jpg' );
		// var material = new THREE.MeshBasicMaterial( { map: texture } );

		// // 改变大小
		// var geometry = new THREE.BoxBufferGeometry( 20, 20, 30 );
		// // geometry.scale(0.2, 0.2, 0.2);

		// mesh = new THREE.Mesh( geometry, material );
		// // 改变位置
		// mesh.translateY(-20);
		// mesh.translateZ(45);

		// group.add( mesh );
		// objects.push( mesh );

		// // 改变位置
		// group.translateX(-150);
		// group.add( new THREE.AxesHelper( 100 ) );

		// // 无效
		// // objects.push( group );

		// // 一个group添加到scene
		// scene.add( group );

		// ////////////////////////////////////////
		// // 圆环
		// // RingBufferGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)
		// var thetaLength = Math.PI * 5 / 3;
		// var geometry = new THREE.RingBufferGeometry( 31, 50, 32, 1, 0, thetaLength);
		// var material = new THREE.MeshBasicMaterial( { color: 0x3366ff, side: THREE.DoubleSide } );
		// var mesh1 = new THREE.Mesh( geometry, material );
		// mesh1.translateY(100);
		// // mesh1.rotation.x += Math.PI / 2;
		// scene.add( mesh1 );

		// // 圆柱
		// // CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
		// var geometry = new THREE.CylinderGeometry( 50, 50, 20, 32, 1, false, 0, thetaLength );
		// var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
		// var cylinder = new THREE.Mesh( geometry, material );
		// // cylinder.translateY(-50);
		// scene.add( cylinder );

		// // 平面1
		// var geometry = new THREE.PlaneGeometry( 20, 20 );
		// var material = new THREE.MeshBasicMaterial( {color: 0xff0000, side: THREE.DoubleSide} );
		// var plane = new THREE.Mesh( geometry, material );
		// plane.rotation.y += Math.PI / 2;
		// // plane.translateY(50);
		// plane.translateX(-30 - 10);
		// scene.add( plane );

		// // 平面2
		// var geometry = new THREE.PlaneGeometry( 100, 100 );
		// var material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		// var plane = new THREE.Mesh( geometry, material );
		// // plane.rotation.y += Math.PI / 2;
		// plane.translateX(-30 - 10);
		// // plane.rotation.y += Math.PI / 3;
		// rotateAroundWorldAxis( plane, new THREE.Vector3(0,1,0), Math.PI / 6 );
		// scene.add( plane );

		// ////////////////////////////////////////
		// // 圆柱
		// // CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
		// var geometry = new THREE.CylinderGeometry( 30, 30, 50, 32 );
		// var material = new THREE.MeshBasicMaterial( {color: 0x555555} );
		// var cylinder = new THREE.Mesh( geometry, material );
		// scene.add( cylinder );

		// ////////////////////////////////////////
		// // 圆球
		// var geometry = new THREE.SphereGeometry( 5, 32, 32 );
		// var material = new THREE.MeshBasicMaterial( {color: 0xff00ff} );
		// var sphere = new THREE.Mesh( geometry, material );
		// sphere.translateY(50);
		// sphere.translateZ(40);
		// scene.add( sphere );
		// ////////////////////////////////////////

		// 下面几个事件都是在 DragControls 中自定义的事件名称

		// 允许拖动objects
		var dragControls = new DragControls(objects, camera, renderer.domElement);
		dragControls.addEventListener('dragstart', function () {

			console.log("dragstart");
			controls.enabled = false;

		});

		dragControls.addEventListener('dragend', function () {

			console.log("dragend");
			controls.enabled = true;

		});

		// 向DragControls注册click事件
		dragControls.addEventListener('click', function () {

			console.log("click");

			// 改变位置
			group.translateY(Math.random() * 40 - 20);
			group.translateZ(Math.random() * 40 - 20);

		});

		// renderer.domElement.addEventListener('touchstart', process_touchstart, false);

		window.addEventListener('resize', onWindowResize, false);

	}

	// touchstart handler
	function process_touchstart(ev) {

		console.log("process_touchstart, ev =", ev);
		// Use the event's data to call out to the appropriate gesture handlers
		switch (ev.touches.length) {

			case 1:
				handle_one_touch(ev);
				break;
			case 2:
				handle_two_touches(ev);
				break;
			case 3:
				handle_three_touches(ev);
				break;
			default:
				gesture_not_supported(ev);
				break;

		}

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);

	}

	function animate() {

		requestAnimationFrame(animate);

		// mesh.rotation.x += 0.0005;
		// mesh.rotation.y += 0.001;
		// mesh.rotation.z += 0.002;

		var deltaTime = clock.getDelta();

		updatePhysics(deltaTime);
		renderer.render(scene, camera);

	}

	function initPhysics() {

		// Physics configuration

		collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
		dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
		broadphase = new Ammo.btDbvtBroadphase();
		solver = new Ammo.btSequentialImpulseConstraintSolver();
		physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
		physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));

		transformAux1 = new Ammo.btTransform();
		tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);

	}

	function createHollowCylinder() {

		var extrudeSettings = {
			amount: 2,
			steps: 1,
			bevelEnabled: false,
			curveSegments: 8
		};

		var arcShape = new THREE.Shape();
		arcShape.absarc(0, 0, 3, 0, Math.PI * 3 / 2, 0, false);

		var holePath = new THREE.Path();
		holePath.absarc(0, 0, 2, 0, Math.PI * 1 / 2, true);
		arcShape.holes.push(holePath);

		var geometry = new THREE.ExtrudeGeometry(arcShape, extrudeSettings);

		var texture = new THREE.TextureLoader().load('textures/land_ocean_ice_cloud_2048.jpg');
		var material = new THREE.MeshBasicMaterial({map: texture});

		mesh = new THREE.Mesh(geometry, material);

		// 改变位置
		mesh.translateY(15);
		// mesh.translateZ(7.5);

		scene.add(mesh);

		/////////////////////////////////////////
		// 无法创建 BreakableObject
		// ConvexObjectBreaker.js:81 THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.
		// var towerMass = 1000;
		// var towerHalfExtents = new THREE.Vector3( 2, 5, 2 );
		// pos.set( - 13.8, 1, 0 );
		// quat.set( 0, 0, 0, 1 );
		// createObject_byMesh( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xB03014 ), mesh );
	}

	function createObject(mass, halfExtents, pos, quat, material) {

		var object = new THREE.Mesh(new THREE.BoxBufferGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2), material);
		object.position.copy(pos);
		object.quaternion.copy(quat);
		convexBreaker.prepareBreakableObject(object, mass, new THREE.Vector3(), new THREE.Vector3(), true);
		createDebrisFromBreakableObject(object);

	}

	function createObjects_custom() {

		////////////////////////////////////////
		// 一个复合对象（group）
		var group = new THREE.Group();

		// 一个box几何体
		// var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
		var texture = new THREE.TextureLoader().load('textures/land_ocean_ice_cloud_2048.jpg');
		var material = new THREE.MeshBasicMaterial({map: texture});

		var geometry = new THREE.BoxBufferGeometry(10, 10, 10);

		mesh = new THREE.Mesh(geometry, material);
		group.add(mesh);

		// 第二个box几何体
		// var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
		var texture = new THREE.TextureLoader().load('textures/water.jpg');
		var material = new THREE.MeshBasicMaterial({map: texture});

		// 改变大小
		var geometry = new THREE.BoxBufferGeometry(3, 3, 4);
		// geometry.scale(0.2, 0.2, 0.2);

		mesh = new THREE.Mesh(geometry, material);
		// 改变位置
		mesh.translateY(-50);
		mesh.translateZ(7.5);

		group.add(mesh);
		objects.push(group);

		// 改变位置
		group.translateX(20);
		group.add(new THREE.AxesHelper(100));

		// 一个group添加到scene
		scene.add(group);

		// Tower 1
		var towerMass = 1000;
		var towerHalfExtents = new THREE.Vector3(2, 5, 2);
		pos.set(-13.8, 1, 0);
		quat.set(0, 0, 0, 1);
		createObject_byMesh(towerMass, towerHalfExtents, pos, quat, createMaterial(0xB03014), mesh);
	}

	function createObject_byMesh(mass, halfExtents, pos, quat, material, mesh) {

		var object = mesh;
		object.position.copy(pos);
		object.quaternion.copy(quat);
		convexBreaker.prepareBreakableObject(object, mass, new THREE.Vector3(), new THREE.Vector3(), true);
		createDebrisFromBreakableObject(object);

	}

	function createObjects() {

		// Ground
		pos.set(0, -0.5, 0);
		quat.set(0, 0, 0, 1);
		var ground = createParalellepipedWithPhysics(40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial({color: 0xFFFFFF}));
		ground.receiveShadow = true;
		textureLoader.load("textures/grid.png", function (texture) {

			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(40, 40);
			ground.material.map = texture;
			ground.material.needsUpdate = true;

		});

		// Tower 1
		var towerMass = 1000;
		var towerHalfExtents = new THREE.Vector3(2, 5, 2);
		pos.set(-8, 5, 0);
		quat.set(0, 0, 0, 1);
		createObject(towerMass, towerHalfExtents, pos, quat, createMaterial(0xB03014));

		// Tower 2
		pos.set(8, 5, 0);
		quat.set(0, 0, 0, 1);
		createObject(towerMass, towerHalfExtents, pos, quat, createMaterial(0xB03214));

		//Bridge
		var bridgeMass = 100;
		var bridgeHalfExtents = new THREE.Vector3(7, 0.2, 1.5);
		pos.set(0, 10.2, 0);
		quat.set(0, 0, 0, 1);
		createObject(bridgeMass, bridgeHalfExtents, pos, quat, createMaterial(0xB3B865));

		// Stones
		var stoneMass = 120;
		var stoneHalfExtents = new THREE.Vector3(1, 2, 0.15);
		var numStones = 8;
		quat.set(0, 0, 0, 1);
		for (var i = 0; i < numStones; i++) {

			pos.set(0, 2, 15 * (0.5 - i / (numStones + 1)));

			createObject(stoneMass, stoneHalfExtents, pos, quat, createMaterial(0xB0B0B0));

		}

		// Mountain
		var mountainMass = 860;
		var mountainHalfExtents = new THREE.Vector3(4, 5, 4);
		pos.set(5, mountainHalfExtents.y * 0.5, -7);
		quat.set(0, 0, 0, 1);
		var mountainPoints = [];
		mountainPoints.push(new THREE.Vector3(mountainHalfExtents.x, -mountainHalfExtents.y, mountainHalfExtents.z));
		mountainPoints.push(new THREE.Vector3(-mountainHalfExtents.x, -mountainHalfExtents.y, mountainHalfExtents.z));
		mountainPoints.push(new THREE.Vector3(0, mountainHalfExtents.y, 0));
		mountainPoints.push(new THREE.Vector3(mountainHalfExtents.x, -mountainHalfExtents.y, -mountainHalfExtents.z));
		mountainPoints.push(new THREE.Vector3(-mountainHalfExtents.x, -mountainHalfExtents.y, -mountainHalfExtents.z));
		var mountain = new THREE.Mesh(new ConvexBufferGeometry(mountainPoints), createMaterial(0xB03814));
		mountain.position.copy(pos);
		mountain.quaternion.copy(quat);
		convexBreaker.prepareBreakableObject(mountain, mountainMass, new THREE.Vector3(), new THREE.Vector3(), true);
		createDebrisFromBreakableObject(mountain);

	}

	function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {

		var object = new THREE.Mesh(new THREE.BoxBufferGeometry(sx, sy, sz, 1, 1, 1), material);
		var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
		shape.setMargin(margin);

		createRigidBody(object, shape, mass, pos, quat);

		return object;

	}

	function createDebrisFromBreakableObject(object) {

		object.castShadow = true;
		object.receiveShadow = true;

		var shape = createConvexHullPhysicsShape(object.geometry.attributes.position.array);
		shape.setMargin(margin);

		var body = createRigidBody(object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity);

		// Set pointer back to the three object only in the debris objects
		var btVecUserData = new Ammo.btVector3(0, 0, 0);
		btVecUserData.threeObject = object;
		body.setUserPointer(btVecUserData);

	}

	function removeDebris(object) {

		scene.remove(object);

		physicsWorld.removeRigidBody(object.userData.physicsBody);

	}

	/**
	 * 给定一个顶点数组 coords，计算出其凸包 Ammo.btConvexHullShape
	 */
	function createConvexHullPhysicsShape(coords) {

		var shape = new Ammo.btConvexHullShape();

		for (var i = 0, il = coords.length; i < il; i += 3) {

			tempBtVec3_1.setValue(coords[i], coords[i + 1], coords[i + 2]);
			var lastOne = (i >= (il - 3));
			shape.addPoint(tempBtVec3_1, lastOne);

		}

		return shape;

	}

	/**
	 * 创建一个 RigidBody
	 * object: 一个mesh
	 * physicsShape:
	 */
	function createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {

		if (pos) {

			object.position.copy(pos);

		} else {

			pos = object.position;

		}
		if (quat) {

			object.quaternion.copy(quat);

		} else {

			quat = object.quaternion;

		}

		var transform = new Ammo.btTransform();
		transform.setIdentity();
		transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
		transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
		var motionState = new Ammo.btDefaultMotionState(transform);

		var localInertia = new Ammo.btVector3(0, 0, 0);
		physicsShape.calculateLocalInertia(mass, localInertia);

		var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
		var body = new Ammo.btRigidBody(rbInfo);

		body.setFriction(0.5);

		if (vel) {

			body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));

		}
		if (angVel) {

			body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));

		}

		object.userData.physicsBody = body;
		object.userData.collided = false;

		scene.add(object);

		if (mass > 0) {

			rigidBodies.push(object);

			// Disable deactivation
			body.setActivationState(4);

		}

		physicsWorld.addRigidBody(body);

		return body;

	}

	function createRandomColor() {

		return Math.floor(Math.random() * (1 << 24));

	}

	function createMaterial(color) {

		color = color || createRandomColor();
		return new THREE.MeshPhongMaterial({color: color});

	}

	function initInput() {

		window.addEventListener('mousedown', function (event) {

			mouseCoords.set(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1
			);

			raycaster.setFromCamera(mouseCoords, camera);

			// Creates a ball and throws it
			var ballMass = 35;
			var ballRadius = 0.4;

			var ball = new THREE.Mesh(new THREE.SphereBufferGeometry(ballRadius, 14, 10), ballMaterial);
			ball.castShadow = true;
			ball.receiveShadow = true;
			var ballShape = new Ammo.btSphereShape(ballRadius);
			ballShape.setMargin(margin);
			pos.copy(raycaster.ray.direction);
			pos.add(raycaster.ray.origin);
			quat.set(0, 0, 0, 1);
			var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);

			pos.copy(raycaster.ray.direction);
			pos.multiplyScalar(24);
			ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

		}, false);

	}

	var rotWorldMatrix;

	// Rotate an object around an arbitrary axis in world space
	function rotateAroundWorldAxis(object, axis, radians) {

		rotWorldMatrix = new THREE.Matrix4();
		rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
		rotWorldMatrix.multiply(object.matrix); // pre-multiply
		object.matrix = rotWorldMatrix;
		object.rotation.setFromRotationMatrix(object.matrix);
	}

	function updatePhysics(deltaTime) {

		// Step world
		physicsWorld.stepSimulation(deltaTime, 10);

		// Update rigid bodies
		for (var i = 0, il = rigidBodies.length; i < il; i++) {

			// Three.Mesh
			var objThree = rigidBodies[i];
			// Ammo.btRigidBody
			var objPhys = objThree.userData.physicsBody;
			var ms = objPhys.getMotionState();

			if (ms) {

				ms.getWorldTransform(transformAux1);
				var p = transformAux1.getOrigin();
				var q = transformAux1.getRotation();
				objThree.position.set(p.x(), p.y(), p.z());
				objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

				objThree.userData.collided = false;

			}

		}

		// 处理碰撞
		for (var i = 0, il = dispatcher.getNumManifolds(); i < il; i++) {

			var contactManifold = dispatcher.getManifoldByIndexInternal(i);
			var rb0 = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
			var rb1 = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);

			var threeObject0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject;
			var threeObject1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject;

			if (!threeObject0 && !threeObject1) {

				continue;

			}

			var userData0 = threeObject0 ? threeObject0.userData : null;
			var userData1 = threeObject1 ? threeObject1.userData : null;

			var breakable0 = userData0 ? userData0.breakable : false;
			var breakable1 = userData1 ? userData1.breakable : false;

			var collided0 = userData0 ? userData0.collided : false;
			var collided1 = userData1 ? userData1.collided : false;

			if ((!breakable0 && !breakable1) || (collided0 && collided1)) {

				continue;

			}

			var contact = false;
			var maxImpulse = 0;
			for (var j = 0, jl = contactManifold.getNumContacts(); j < jl; j++) {

				var contactPoint = contactManifold.getContactPoint(j);

				if (contactPoint.getDistance() < 0) {

					contact = true;
					var impulse = contactPoint.getAppliedImpulse();

					if (impulse > maxImpulse) {

						maxImpulse = impulse;
						var pos = contactPoint.get_m_positionWorldOnB();
						var normal = contactPoint.get_m_normalWorldOnB();
						impactPoint.set(pos.x(), pos.y(), pos.z());
						impactNormal.set(normal.x(), normal.y(), normal.z());

					}

					break;

				}

			}

			// If no point has contact, abort
			if (!contact) continue;

			// Subdivision

			var fractureImpulse = 250;

			if (breakable0 && !collided0 && maxImpulse > fractureImpulse) {

				var debris = convexBreaker.subdivideByImpact(threeObject0, impactPoint, impactNormal, 1, 2, 1.5);

				var numObjects = debris.length;
				for (var j = 0; j < numObjects; j++) {

					var vel = rb0.getLinearVelocity();
					var angVel = rb0.getAngularVelocity();
					var fragment = debris[j];
					fragment.userData.velocity.set(vel.x(), vel.y(), vel.z());
					fragment.userData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());

					createDebrisFromBreakableObject(fragment);

				}

				objectsToRemove[numObjectsToRemove++] = threeObject0;
				userData0.collided = true;

			}

			if (breakable1 && !collided1 && maxImpulse > fractureImpulse) {

				var debris = convexBreaker.subdivideByImpact(threeObject1, impactPoint, impactNormal, 1, 2, 1.5);

				var numObjects = debris.length;
				for (var j = 0; j < numObjects; j++) {

					var vel = rb1.getLinearVelocity();
					var angVel = rb1.getAngularVelocity();
					var fragment = debris[j];
					fragment.userData.velocity.set(vel.x(), vel.y(), vel.z());
					fragment.userData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());

					createDebrisFromBreakableObject(fragment);

				}

				objectsToRemove[numObjectsToRemove++] = threeObject1;
				userData1.collided = true;

			}

		}

		for (var i = 0; i < numObjectsToRemove; i++) {

			removeDebris(objectsToRemove[i]);

		}
		numObjectsToRemove = 0;

	}

</script>

</body>
</html>
